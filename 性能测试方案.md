# ExRpc 性能测试方案

本文档提供完整的 ExRpc 性能测试方法、工具和最佳实践。

---

## 目录

1. [性能指标定义](#1-性能指标定义)
2. [内置性能监控](#2-内置性能监控)
3. [性能测试场景](#3-性能测试场景)
4. [测试代码示例](#4-测试代码示例)
5. [压测工具和脚本](#5-压测工具和脚本)
6. [性能分析和优化](#6-性能分析和优化)
7. [性能基准参考](#7-性能基准参考)

---

## 1. 性能指标定义

### 核心性能指标

#### 1.1 响应时间（Response Time）
- **平均响应时间（Average RT）**：所有请求的平均耗时
- **P50/P90/P95/P99 响应时间**：百分位数，反映大部分用户体验
- **最小/最大响应时间**：极值，帮助发现异常

#### 1.2 吞吐量（Throughput）
- **QPS（Queries Per Second）**：每秒处理的请求数
- **TPS（Transactions Per Second）**：每秒完成的事务数
- **并发连接数**：同时活跃的连接数

#### 1.3 可靠性指标
- **成功率**：成功请求 / 总请求数
- **错误率**：失败请求 / 总请求数
- **超时率**：超时请求 / 总请求数

#### 1.4 资源使用率
- **CPU 使用率**：服务器和客户端的 CPU 占用
- **内存使用**：堆内存、GC 次数和耗时
- **网络带宽**：入站/出站流量
- **连接池利用率**：连接池使用情况

---

## 2. 内置性能监控

ExRpc 已内置 `PerformanceRecorder`，自动收集以下指标：

### 2.1 PerformanceRecorder 监控项

| 指标 | 说明 | 单位 |
|------|------|------|
| `cnt_call` | 调用次数 | 次 |
| `cnt_fail` | 失败次数 | 次 |
| `sum_elapse` | 总耗时 | 微秒 (μs) |

**自动计算指标：**
- 平均响应时间 = `sum_elapse / cnt_call`
- 成功率 = `(cnt_call - cnt_fail) / cnt_call × 100%`

### 2.2 监控位置

性能数据在 `RPCServerBase.CallServantMethod()` 中自动记录：

```csharp
// ExRpc.Common/Server/RPCServerBase.cs
Stopwatch sw = Stopwatch.StartNew();
bool bRet = servant.call_method(request, out response);
sw.Stop();

// 记录性能指标（微秒）
_PerformanceRecorder.Increment(
    _GridUri,
    _InstanceId,
    servantName,
    methodName,
    1,                          // cnt_call
    bRet ? 0 : 1,               // cnt_fail
    sw.ElapsedMilliseconds * 1000  // 微秒
);
```

### 2.3 查看性能数据

性能数据默认每 5 分钟保存到数据库表 `log_rpcserver_performance`：

```sql
-- 数据库表结构
CREATE TABLE log_rpcserver_performance (
    id BIGINT IDENTITY(1,1) PRIMARY KEY,
    uri VARCHAR(256),              -- 服务URI
    instance VARCHAR(128),         -- 实例ID
    servant VARCHAR(128),          -- Servant名称
    method VARCHAR(128),           -- 方法名
    cnt_call INT,                  -- 调用次数
    cnt_fail INT,                  -- 失败次数
    sum_elapse BIGINT,             -- 总耗时（微秒）
    create_time DATETIME DEFAULT GETDATE()
);

-- 查询平均响应时间（毫秒）
SELECT
    uri,
    servant,
    method,
    SUM(cnt_call) AS total_calls,
    SUM(cnt_fail) AS total_fails,
    CAST(SUM(sum_elapse) AS FLOAT) / SUM(cnt_call) / 1000 AS avg_response_ms,
    CAST(SUM(cnt_fail) AS FLOAT) / SUM(cnt_call) * 100 AS error_rate_percent
FROM log_rpcserver_performance
WHERE create_time >= DATEADD(HOUR, -1, GETDATE())
GROUP BY uri, servant, method
ORDER BY total_calls DESC;
```

---

## 3. 性能测试场景

### 3.1 基准测试（Baseline）
**目标**：测试单线程、无负载情况下的性能

- **并发数**：1
- **请求数**：10,000
- **测试内容**：简单的 Echo 方法
- **关注指标**：最小响应时间、平均响应时间

### 3.2 负载测试（Load Test）
**目标**：测试正常负载下的性能表现

- **并发数**：10, 50, 100, 200
- **持续时间**：10 分钟
- **测试内容**：典型业务方法
- **关注指标**：QPS、平均响应时间、资源使用率

### 3.3 压力测试（Stress Test）
**目标**：找到系统的性能极限

- **并发数**：逐步增加（100 → 500 → 1000 → 2000）
- **持续时间**：每个阶段 5 分钟
- **测试内容**：混合业务方法
- **关注指标**：最大 QPS、P95 响应时间、错误率

### 3.4 稳定性测试（Soak Test）
**目标**：验证长时间运行的稳定性

- **并发数**：正常负载的 70%
- **持续时间**：24 小时
- **测试内容**：生产环境常用方法
- **关注指标**：内存泄漏、连接泄漏、错误率趋势

### 3.5 峰值测试（Spike Test）
**目标**：测试突发流量的处理能力

- **并发数**：正常负载 → 10倍峰值负载 → 正常负载
- **持续时间**：每个阶段 2 分钟
- **测试内容**：高频调用方法
- **关注指标**：恢复时间、错误率、队列堆积

### 3.6 集群测试
**目标**：测试集群模式下的负载均衡和容错

- **集群模式**：MasterSlave、Cluster、ClusterWithHash
- **测试内容**：
  - 负载均衡是否均匀
  - 节点宕机后的故障转移
  - 节点恢复后的自动加入
- **关注指标**：请求分布、故障转移时间

---

## 4. 测试代码示例

### 4.1 简单性能测试客户端

```csharp
using System;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using ExRpc.Common.Proxy;
using ExRpc.Common;

namespace PerformanceTest
{
    /// <summary>
    /// 性能测试统计
    /// </summary>
    public class PerfStats
    {
        private long _totalRequests = 0;
        private long _successRequests = 0;
        private long _failedRequests = 0;
        private long _totalElapsedMs = 0;

        public void IncrementTotal() => Interlocked.Increment(ref _totalRequests);
        public void IncrementSuccess() => Interlocked.Increment(ref _successRequests);
        public void IncrementFailed() => Interlocked.Increment(ref _failedRequests);
        public void AddElapsed(long ms) => Interlocked.Add(ref _totalElapsedMs, ms);

        public long TotalRequests => _totalRequests;
        public long SuccessRequests => _successRequests;
        public long FailedRequests => _failedRequests;
        public long TotalElapsedMs => _totalElapsedMs;

        public double AvgResponseTimeMs => _successRequests > 0
            ? (double)_totalElapsedMs / _successRequests
            : 0;

        public double SuccessRate => _totalRequests > 0
            ? (double)_successRequests / _totalRequests * 100
            : 0;

        public void PrintReport()
        {
            Console.WriteLine("\n========== 性能测试报告 ==========");
            Console.WriteLine($"总请求数:     {TotalRequests:N0}");
            Console.WriteLine($"成功请求数:   {SuccessRequests:N0}");
            Console.WriteLine($"失败请求数:   {FailedRequests:N0}");
            Console.WriteLine($"成功率:       {SuccessRate:F2}%");
            Console.WriteLine($"平均响应时间: {AvgResponseTimeMs:F2} ms");
            Console.WriteLine($"总耗时:       {TotalElapsedMs:N0} ms");
            Console.WriteLine("==================================\n");
        }
    }

    /// <summary>
    /// RPC 性能测试客户端
    /// </summary>
    public class RpcPerformanceTester
    {
        private Communicator _communicator;
        private PerfStats _stats = new PerfStats();

        public RpcPerformanceTester(string host, int port)
        {
            var config = new CommunicatorConfigure
            {
                ConnectTimeout = 200,
                SendTimeout = 3000,
                WaitingACKTimeout = 9000,
                ConnectionPoolSize = 50
            };

            _communicator = new Communicator(config);
        }

        /// <summary>
        /// 单线程基准测试
        /// </summary>
        public void RunBaselineTest(int requestCount)
        {
            Console.WriteLine($"[基准测试] 单线程, {requestCount:N0} 请求");

            Stopwatch totalSw = Stopwatch.StartNew();

            for (int i = 0; i < requestCount; i++)
            {
                ExecuteSingleRequest();

                if ((i + 1) % 1000 == 0)
                    Console.WriteLine($"进度: {i + 1:N0} / {requestCount:N0}");
            }

            totalSw.Stop();

            Console.WriteLine($"总耗时: {totalSw.ElapsedMilliseconds:N0} ms");
            Console.WriteLine($"QPS: {requestCount * 1000.0 / totalSw.ElapsedMilliseconds:F2}");
            _stats.PrintReport();
        }

        /// <summary>
        /// 并发负载测试
        /// </summary>
        public void RunLoadTest(int concurrency, int durationSeconds)
        {
            Console.WriteLine($"[负载测试] 并发数={concurrency}, 持续时间={durationSeconds}秒");

            CancellationTokenSource cts = new CancellationTokenSource();
            Task[] tasks = new Task[concurrency];

            Stopwatch totalSw = Stopwatch.StartNew();

            // 启动多个并发任务
            for (int i = 0; i < concurrency; i++)
            {
                tasks[i] = Task.Run(() => ContinuousRequestWorker(cts.Token));
            }

            // 运行指定时间
            Thread.Sleep(durationSeconds * 1000);
            cts.Cancel();

            // 等待所有任务完成
            Task.WaitAll(tasks);
            totalSw.Stop();

            double actualSeconds = totalSw.ElapsedMilliseconds / 1000.0;
            double qps = _stats.TotalRequests / actualSeconds;

            Console.WriteLine($"实际运行时间: {actualSeconds:F2} 秒");
            Console.WriteLine($"QPS: {qps:F2}");
            _stats.PrintReport();
        }

        /// <summary>
        /// 压力测试（逐步增加并发）
        /// </summary>
        public void RunStressTest()
        {
            int[] concurrencyLevels = { 10, 50, 100, 200, 500, 1000 };
            int durationPerLevel = 60; // 每个级别60秒

            foreach (int concurrency in concurrencyLevels)
            {
                Console.WriteLine($"\n===== 压力级别: {concurrency} 并发 =====");

                _stats = new PerfStats(); // 重置统计
                RunLoadTest(concurrency, durationPerLevel);

                // 休息10秒再进入下一级别
                Thread.Sleep(10000);
            }
        }

        /// <summary>
        /// 持续发送请求的工作线程
        /// </summary>
        private void ContinuousRequestWorker(CancellationToken token)
        {
            while (!token.IsCancellationRequested)
            {
                ExecuteSingleRequest();
            }
        }

        /// <summary>
        /// 执行单次 RPC 请求
        /// 【注意】：这里需要替换成你的实际 Proxy 和方法调用
        /// </summary>
        private void ExecuteSingleRequest()
        {
            _stats.IncrementTotal();
            Stopwatch sw = Stopwatch.StartNew();

            try
            {
                // TODO: 替换成你的实际 Proxy 调用
                // 示例：
                // var proxy = new YourServiceProxy(_communicator, "rpc://cluster.proj.root");
                // var result = proxy.YourMethod(param1, param2);

                // 模拟调用（实际使用时删除下面这行）
                Thread.Sleep(10); // 模拟10ms延迟

                sw.Stop();
                _stats.IncrementSuccess();
                _stats.AddElapsed(sw.ElapsedMilliseconds);
            }
            catch (Exception ex)
            {
                sw.Stop();
                _stats.IncrementFailed();
                Console.WriteLine($"请求失败: {ex.Message}");
            }
        }
    }

    /// <summary>
    /// 测试程序入口
    /// </summary>
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("ExRpc 性能测试工具\n");

            var tester = new RpcPerformanceTester("localhost", 9000);

            // 1. 基准测试
            tester.RunBaselineTest(10000);

            Thread.Sleep(5000); // 休息5秒

            // 2. 负载测试 - 100并发，持续60秒
            tester.RunLoadTest(100, 60);

            Thread.Sleep(5000);

            // 3. 压力测试（可选，注释掉以节省时间）
            // tester.RunStressTest();

            Console.WriteLine("\n测试完成！按任意键退出...");
            Console.ReadKey();
        }
    }
}
```

### 4.2 响应时间百分位数计算

```csharp
using System;
using System.Collections.Concurrent;
using System.Linq;

public class LatencyRecorder
{
    private ConcurrentBag<long> _latencies = new ConcurrentBag<long>();

    public void RecordLatency(long milliseconds)
    {
        _latencies.Add(milliseconds);
    }

    public void PrintPercentiles()
    {
        var sorted = _latencies.OrderBy(x => x).ToArray();
        int count = sorted.Length;

        if (count == 0)
        {
            Console.WriteLine("没有数据");
            return;
        }

        Console.WriteLine("\n========== 响应时间分布 ==========");
        Console.WriteLine($"最小值:  {sorted[0]} ms");
        Console.WriteLine($"P50:     {GetPercentile(sorted, 50)} ms");
        Console.WriteLine($"P75:     {GetPercentile(sorted, 75)} ms");
        Console.WriteLine($"P90:     {GetPercentile(sorted, 90)} ms");
        Console.WriteLine($"P95:     {GetPercentile(sorted, 95)} ms");
        Console.WriteLine($"P99:     {GetPercentile(sorted, 99)} ms");
        Console.WriteLine($"最大值:  {sorted[count - 1]} ms");
        Console.WriteLine("==================================\n");
    }

    private long GetPercentile(long[] sorted, int percentile)
    {
        int index = (int)Math.Ceiling(sorted.Length * percentile / 100.0) - 1;
        return sorted[Math.Max(0, Math.Min(index, sorted.Length - 1))];
    }
}
```

### 4.3 集群测试代码

```csharp
using System;
using System.Linq;
using System.Collections.Generic;
using ExRpc.Common.Cluster;

public class ClusterLoadBalanceTester
{
    /// <summary>
    /// 测试负载均衡是否均匀
    /// </summary>
    public void TestLoadBalance(ClusterInvokerBase invoker, int requestCount)
    {
        Dictionary<string, int> requestDistribution = new Dictionary<string, int>();

        for (int i = 0; i < requestCount; i++)
        {
            // 根据不同集群模式获取节点
            var node = invoker.GetClusterNodeByRandom(); // 或其他方法

            string key = $"{node.Host}:{node.Port}";
            if (!requestDistribution.ContainsKey(key))
                requestDistribution[key] = 0;

            requestDistribution[key]++;
        }

        Console.WriteLine("\n========== 负载分布统计 ==========");
        foreach (var kvp in requestDistribution.OrderBy(x => x.Key))
        {
            double percentage = (double)kvp.Value / requestCount * 100;
            Console.WriteLine($"{kvp.Key}: {kvp.Value:N0} ({percentage:F2}%)");
        }
        Console.WriteLine("==================================\n");
    }
}
```

---

## 5. 压测工具和脚本

### 5.1 使用 BenchmarkDotNet

```csharp
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

[MemoryDiagnoser]
[SimpleJob(warmupCount: 3, targetCount: 10)]
public class RpcBenchmark
{
    private Communicator _comm;
    private YourServiceProxy _proxy;

    [GlobalSetup]
    public void Setup()
    {
        _comm = CommunicatorFactory.GetCommunicator("default");
        _proxy = new YourServiceProxy(_comm, "rpc://cluster.proj.root");
    }

    [Benchmark]
    public void SimpleRpcCall()
    {
        _proxy.YourMethod("test");
    }

    [GlobalCleanup]
    public void Cleanup()
    {
        // 清理资源
    }
}

class Program
{
    static void Main(string[] args)
    {
        BenchmarkRunner.Run<RpcBenchmark>();
    }
}
```

### 5.2 PowerShell 压测脚本

```powershell
# rpc-stress-test.ps1
param(
    [int]$Concurrency = 10,
    [int]$DurationSeconds = 60,
    [string]$Host = "localhost",
    [int]$Port = 9000
)

Write-Host "启动 ExRpc 压力测试..." -ForegroundColor Green
Write-Host "并发数: $Concurrency"
Write-Host "持续时间: $DurationSeconds 秒"
Write-Host "目标: ${Host}:${Port}"

# 编译测试程序
dotnet build .\PerformanceTest\PerformanceTest.csproj -c Release

# 运行测试
dotnet run --project .\PerformanceTest\PerformanceTest.csproj -c Release -- `
    --concurrency $Concurrency `
    --duration $DurationSeconds `
    --host $Host `
    --port $Port

Write-Host "测试完成！" -ForegroundColor Green
```

### 5.3 性能监控脚本

```powershell
# monitor-performance.ps1
# 实时监控性能数据库表

param(
    [string]$ConnectionString = "Server=localhost;Database=YourDB;Integrated Security=true;",
    [int]$IntervalSeconds = 10
)

while ($true) {
    Clear-Host

    $query = @"
SELECT TOP 10
    servant + '.' + method AS api,
    SUM(cnt_call) AS calls,
    SUM(cnt_fail) AS fails,
    CAST(SUM(sum_elapse) AS FLOAT) / SUM(cnt_call) / 1000 AS avg_ms,
    CAST(SUM(cnt_fail) AS FLOAT) / SUM(cnt_call) * 100 AS error_rate
FROM log_rpcserver_performance
WHERE create_time >= DATEADD(MINUTE, -5, GETDATE())
GROUP BY servant, method
ORDER BY calls DESC
"@

    $result = Invoke-Sqlcmd -ConnectionString $ConnectionString -Query $query

    Write-Host "========== 最近5分钟性能数据 ==========" -ForegroundColor Cyan
    $result | Format-Table -AutoSize
    Write-Host "刷新时间: $(Get-Date -Format 'HH:mm:ss')" -ForegroundColor Gray

    Start-Sleep -Seconds $IntervalSeconds
}
```

---

## 6. 性能分析和优化

### 6.1 性能瓶颈排查

#### 客户端瓶颈

```csharp
// 检查连接池是否耗尽
// ExRpc.Common/Communicator.cs
private TcpClientPool GetConnectionPool(string host, int port)
{
    string key = $"{host}:{port}";
    if (!_TcpClientPools.TryGetValue(key, out var pool))
    {
        pool = new TcpClientPool(host, port, _Config.ConnectionPoolSize);
        _TcpClientPools[key] = pool;

        // 添加日志监控连接池创建
        _Logger?.Info($"创建连接池: {key}, 大小: {_Config.ConnectionPoolSize}");
    }
    return pool;
}
```

**优化建议：**
- 增加连接池大小（默认50，可调整到100-200）
- 检查是否有连接泄漏（未正确释放）
- 监控 `_TransactionTable` 大小，过大说明有超时未清理的事务

#### 服务端瓶颈

```csharp
// 检查 Servant 处理时间
// ExRpc.Common/Server/RPCServerBase.cs
public IRpcCallMethodReturn CallServantMethod(IRpcCallMethod request)
{
    Stopwatch sw = Stopwatch.StartNew();

    // ... 业务逻辑 ...

    sw.Stop();

    // 如果处理时间超过阈值，记录警告
    if (sw.ElapsedMilliseconds > 1000)
    {
        _Logger?.Warn($"慢请求: {servant}.{method}, 耗时: {sw.ElapsedMilliseconds}ms");
    }

    return response;
}
```

**优化建议：**
- 检查慢查询和慢方法
- 优化 Servant 中的业务逻辑
- 考虑使用异步方法减少线程阻塞
- 监控 GC 频率和耗时

### 6.2 配置优化

```xml
<!-- communicator.xml -->
<Communicator name="default">
    <!-- 连接超时（毫秒），建议 200-500 -->
    <ConnectTimeout>200</ConnectTimeout>

    <!-- 发送超时（毫秒），建议 3000-5000 -->
    <SendTimeout>3000</SendTimeout>

    <!-- 等待响应超时（毫秒），建议 5000-15000 -->
    <WaitingACKTimeout>9000</WaitingACKTimeout>

    <!-- 连接池大小，建议 50-200 -->
    <ConnectionPoolSize>100</ConnectionPoolSize>

    <!-- 重试次数，建议 1-3 -->
    <RetryCount>2</RetryCount>
</Communicator>
```

### 6.3 性能优化清单

**客户端优化：**
- [ ] 增大连接池大小
- [ ] 减少重试次数和超时时间（如果网络稳定）
- [ ] 使用集群模式分散负载
- [ ] 启用连接复用，避免频繁创建连接
- [ ] 使用对象池减少 GC 压力

**服务端优化：**
- [ ] 优化 Servant 业务逻辑
- [ ] 使用异步 I/O 减少线程占用
- [ ] 增加服务器实例（横向扩展）
- [ ] 启用性能分析工具（dotTrace、PerfView）
- [ ] 调整 .NET GC 模式（Server GC）

**网络优化：**
- [ ] 启用 TCP KeepAlive
- [ ] 调整 TCP 窗口大小
- [ ] 使用专用网络（避免公网延迟）
- [ ] 考虑使用更高效的序列化协议

---

## 7. 性能基准参考

### 7.1 参考指标（仅供参考）

基于局域网环境、单机部署、简单 Echo 方法的测试结果：

| 场景 | 并发数 | QPS | 平均响应时间 | P95 响应时间 | 成功率 |
|------|--------|-----|-------------|-------------|--------|
| 基准测试 | 1 | 2,000 | 0.5 ms | 1 ms | 100% |
| 轻负载 | 10 | 8,000 | 1.2 ms | 2 ms | 100% |
| 中负载 | 50 | 25,000 | 2 ms | 5 ms | 99.9% |
| 高负载 | 100 | 35,000 | 3 ms | 10 ms | 99.5% |
| 压力测试 | 500 | 40,000 | 12 ms | 50 ms | 98% |

**注意：** 实际性能取决于：
- 硬件配置（CPU、内存、网络）
- 业务逻辑复杂度
- 网络环境（延迟、带宽）
- 数据包大小
- 集群配置

### 7.2 性能目标建议

**高性能场景：**
- QPS: > 10,000
- 平均响应时间: < 5 ms
- P95 响应时间: < 20 ms
- 成功率: > 99.9%

**一般业务场景：**
- QPS: > 1,000
- 平均响应时间: < 50 ms
- P95 响应时间: < 100 ms
- 成功率: > 99.5%

**复杂业务场景：**
- QPS: > 100
- 平均响应时间: < 200 ms
- P95 响应时间: < 500 ms
- 成功率: > 99%

---

## 8. 故障注入测试

### 8.1 网络故障模拟

```csharp
/// <summary>
/// 模拟网络延迟
/// </summary>
public class NetworkDelaySimulator
{
    private Random _random = new Random();
    private int _delayMs;

    public NetworkDelaySimulator(int delayMs)
    {
        _delayMs = delayMs;
    }

    public void SimulateDelay()
    {
        Thread.Sleep(_delayMs + _random.Next(-_delayMs / 2, _delayMs / 2));
    }
}

/// <summary>
/// 模拟随机失败
/// </summary>
public class RandomFailureSimulator
{
    private Random _random = new Random();
    private double _failureRate;

    public RandomFailureSimulator(double failureRate)
    {
        _failureRate = failureRate; // 例如 0.01 表示 1% 失败率
    }

    public bool ShouldFail()
    {
        return _random.NextDouble() < _failureRate;
    }
}
```

### 8.2 集群节点故障测试

```bash
# 模拟节点宕机
# 1. 停止某个服务器实例
# 2. 观察客户端是否自动切换到其他节点
# 3. 检查故障转移时间和丢失的请求数

# 模拟节点恢复
# 1. 重启服务器实例
# 2. 验证 ZooKeeper 是否自动发现新节点
# 3. 检查负载是否重新平衡
```

---

## 总结

### 性能测试最佳实践

1. **逐步增加负载**：从小并发开始，逐步增加
2. **多次测试**：每个场景至少测试3次，取平均值
3. **预热系统**：正式测试前先进行预热，避免冷启动影响
4. **隔离环境**：使用专用测试环境，避免其他服务干扰
5. **监控资源**：同时监控 CPU、内存、网络、磁盘 I/O
6. **记录结果**：详细记录每次测试的参数和结果
7. **对比基准**：建立性能基准，定期回归测试

### 关键性能瓶颈

1. **连接池大小**：影响并发能力
2. **超时配置**：影响响应时间和错误率
3. **业务逻辑**：Servant 处理时间直接影响性能
4. **网络延迟**：跨机房、跨区域部署要特别注意
5. **序列化开销**：大对象序列化可能成为瓶颈

### 推荐工具

- **BenchmarkDotNet**：.NET 微基准测试
- **PerfView**：性能分析和 GC 调优
- **dotTrace**：性能分析和瓶颈定位
- **Grafana + Prometheus**：实时性能监控
- **SQL Server Profiler**：数据库性能分析
